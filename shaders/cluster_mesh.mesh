#version 460
#extension GL_EXT_mesh_shader : require  // Add this line

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;

// Same structures as task shader
struct EnhancedRenderableObject {
    mat4 transform;
    mat4 prevTransform;
    uint meshID;
    uint materialID;
    uint instanceID;
    uint flags;
};

struct MeshInfo {
    uint vertexOffset;
    uint vertexCount;
    uint indexOffset;
    uint indexCount;
    vec3 boundsMin;
    float padding1;
    vec3 boundsMax;
    float padding2;
};

struct MeshVertex {
    vec3 position;
    vec3 normal;
    vec2 texCoord;
    vec4 tangent;
};

// Enhanced UBO (same as task shader)
layout(set = 0, binding = 0) uniform EnhancedClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 invViewMatrix;
    mat4 invProjMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;
    vec4 zPlanes;
    vec4 screenSize;
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint frameNumber;
    float time;
    float deltaTime;
    uint flags;
} ubo;

layout(set = 0, binding = 2) readonly buffer ObjectBuffer {
    EnhancedRenderableObject objects[];
};

layout(set = 0, binding = 5) readonly buffer MeshInfoBuffer {
    MeshInfo meshInfos[];
};

layout(set = 0, binding = 6) readonly buffer VertexBuffer {
    MeshVertex vertices[];
};

layout(set = 0, binding = 7) readonly buffer MeshIndexBuffer {
    uint meshIndices[];
};

// Task payload
struct TaskPayload {
    uint clusterIndex;
    uint objectCount;
    uint objectIndices[32];
    uint lightCount;
    uint lightIndices[16];
};

taskPayloadSharedEXT TaskPayload payload;

// Output attributes
layout(location = 0) out vec3 outWorldPos[];
layout(location = 1) out vec3 outNormal[];
layout(location = 2) out vec3 outTangent[];
layout(location = 3) out vec3 outBitangent[];
layout(location = 4) out vec2 outTexCoord[];
layout(location = 5) out vec3 outViewPos[];
layout(location = 6) out vec4 outPrevClipPos[];
layout(location = 7) out flat uint outMaterialID[];
layout(location = 8) out flat uint outClusterIndex[];
layout(location = 9) out flat uint outInstanceID[];

void main() {
    uint objectIndex = gl_WorkGroupID.x;
    
    // Debug fallback: render a simple triangle if no valid objects
    if (objectIndex >= payload.objectCount || payload.objectCount == 0) {
        if (gl_LocalInvocationIndex == 0 && objectIndex == 0) {
            SetMeshOutputsEXT(3, 1);
            
            // Create a simple colored triangle
            gl_MeshVerticesEXT[0].gl_Position = vec4(-0.5, -0.5, 0.0, 1.0);
            gl_MeshVerticesEXT[1].gl_Position = vec4( 0.5, -0.5, 0.0, 1.0);
            gl_MeshVerticesEXT[2].gl_Position = vec4( 0.0,  0.5, 0.0, 1.0);
            
            gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
            
            // Set debug output attributes
            for (int i = 0; i < 3; i++) {
                outWorldPos[i] = vec3(0.0);
                outNormal[i] = vec3(0.0, 0.0, 1.0);
                outTangent[i] = vec3(1.0, 0.0, 0.0);
                outBitangent[i] = vec3(0.0, 1.0, 0.0);
                outTexCoord[i] = vec2(0.5);
                outViewPos[i] = vec3(0.0);
                outPrevClipPos[i] = vec4(0.0);
                outMaterialID[i] = 0;
                outClusterIndex[i] = payload.clusterIndex;
                outInstanceID[i] = 0;
            }
        }
        return;
    }
    
    uint globalObjectIndex = payload.objectIndices[objectIndex];
    if (globalObjectIndex >= objects.length()) {
        return;
    }
    
    EnhancedRenderableObject obj = objects[globalObjectIndex];
    
    if (obj.meshID >= meshInfos.length()) {
        return;
    }
    
    MeshInfo meshInfo = meshInfos[obj.meshID];
    
    // Calculate LOD based on distance (simple implementation)
    vec3 objCenter = (obj.transform * vec4((meshInfo.boundsMin + meshInfo.boundsMax) * 0.5, 1.0)).xyz;
    float distance = length(objCenter - ubo.cameraPos.xyz);
    uint lodLevel = 0; // Could implement LOD selection here
    
    // Limit vertices and triangles based on available data and performance
    uint maxVertices = min(meshInfo.vertexCount, 64u);  // Match layout max_vertices
    uint maxTriangles = min(meshInfo.indexCount / 3, 42u);  // Leave room for safety
    
    // Ensure we have valid data
    if (maxVertices == 0 || maxTriangles == 0) {
        return;
    }
    
    SetMeshOutputsEXT(maxVertices, maxTriangles);
    
    // Process vertices
    if (gl_LocalInvocationIndex < maxVertices) {
        uint vertexIndex = meshInfo.vertexOffset + gl_LocalInvocationIndex;
        
        if (vertexIndex < vertices.length()) {
            MeshVertex vertex = vertices[vertexIndex];
            
            // Transform vertex
            vec4 worldPos = obj.transform * vec4(vertex.position, 1.0);
            vec4 viewPos = ubo.viewMatrix * worldPos;
            vec4 clipPos = ubo.projMatrix * viewPos;
            
            // Previous frame position for motion vectors
            vec4 prevWorldPos = obj.prevTransform * vec4(vertex.position, 1.0);
            vec4 prevClipPos = ubo.projMatrix * ubo.viewMatrix * prevWorldPos;
            
            gl_MeshVerticesEXT[gl_LocalInvocationIndex].gl_Position = clipPos;
            
            // Transform normal and tangent
            mat3 normalMatrix = mat3(transpose(inverse(mat3(obj.transform))));
            vec3 worldNormal = normalize(normalMatrix * vertex.normal);
            vec3 worldTangent = normalize(normalMatrix * vertex.tangent.xyz);
            vec3 worldBitangent = cross(worldNormal, worldTangent) * vertex.tangent.w;
            
            // Set output attributes
            outWorldPos[gl_LocalInvocationIndex] = worldPos.xyz;
            outNormal[gl_LocalInvocationIndex] = worldNormal;
            outTangent[gl_LocalInvocationIndex] = worldTangent;
            outBitangent[gl_LocalInvocationIndex] = worldBitangent;
            outTexCoord[gl_LocalInvocationIndex] = vertex.texCoord;
            outViewPos[gl_LocalInvocationIndex] = viewPos.xyz;
            outPrevClipPos[gl_LocalInvocationIndex] = prevClipPos;
            outMaterialID[gl_LocalInvocationIndex] = obj.materialID;
            outClusterIndex[gl_LocalInvocationIndex] = payload.clusterIndex;
            outInstanceID[gl_LocalInvocationIndex] = obj.instanceID;
        }
    }
    
    // Process indices - ensure we don't exceed triangle limit
    uint triangleIndex = gl_LocalInvocationIndex;
    if (triangleIndex < maxTriangles) {
        uint baseIndex = meshInfo.indexOffset + triangleIndex * 3;
        
        if (baseIndex + 2 < meshIndices.length()) {
            uint i0 = meshIndices[baseIndex];
            uint i1 = meshIndices[baseIndex + 1];
            uint i2 = meshIndices[baseIndex + 2];
            
            // Make indices relative to our vertex offset within the mesh
            i0 = i0 - meshInfo.vertexOffset;
            i1 = i1 - meshInfo.vertexOffset;
            i2 = i2 - meshInfo.vertexOffset;
            
            // Ensure indices are within our vertex range
            if (i0 < maxVertices && i1 < maxVertices && i2 < maxVertices) {
                gl_PrimitiveTriangleIndicesEXT[triangleIndex] = uvec3(i0, i1, i2);
            }
        }
    }
}