#version 460
#extension GL_EXT_mesh_shader : require

// Add struct definitions
struct Cluster {
    uint lightOffset;
    uint lightCount;
    uint objectOffset;
    uint objectCount;
};

struct RenderableObject {
    mat4 transform;
    mat4 prevTransform;
    uint meshID;
    uint materialID;
};

struct ClusterLight {
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
    int type;
    float spotAngle;
    float spotSoftness;
    float padding;
};

// Add descriptor bindings
layout(set = 0, binding = 0) uniform ClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;
    vec4 zPlanes;
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint padding;
};

layout(set = 0, binding = 1) buffer ClusterBuffer {
    Cluster clusters[];
};

layout(set = 0, binding = 2) buffer ObjectBuffer {
    RenderableObject objects[];
};

layout(set = 0, binding = 3) buffer LightBuffer {
    ClusterLight lights[];
};

layout(set = 0, binding = 4) buffer IndexBuffer {
    uint indices[];
};

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 32) out;

// Keep minimal required outputs matching fragment shader inputs
layout(location = 0) out vec3 outPosition[];
layout(location = 1) out vec3 outNormal[];
layout(location = 2) out vec2 outTexCoord[];
layout(location = 3) out vec4 outColor[];
layout(location = 4) out flat uint outObjectID[];

// Shared data for all threads in the workgroup
shared uint s_numTriangles;
shared bool s_shouldOutput;

void main() {
    // ALWAYS draw a triangle for debugging
    if (gl_LocalInvocationIndex == 0 && gl_WorkGroupID.x == 0) {
        // Output a single triangle
        SetMeshOutputsEXT(3, 1);
        
        // Fixed positions in world space
        vec3 positions[3] = vec3[3](
            vec3(0.0, 1.0, 0.0),
            vec3(-1.0, -1.0, 0.0),
            vec3(1.0, -1.0, 0.0)
        );
        
        // Transform to clip space
        for (int i = 0; i < 3; i++) {
            gl_MeshVerticesEXT[i].gl_Position = projMatrix * viewMatrix * vec4(positions[i], 1.0);
            outPosition[i] = positions[i];
        }
        
        // Set indices
        gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
        
        // Bright red color
        outColor[0] = outColor[1] = outColor[2] = vec4(1.0, 0.0, 0.0, 1.0);
        
        // Set other attributes
        outNormal[0] = outNormal[1] = outNormal[2] = vec3(0.0, 0.0, 1.0);
        outTexCoord[0] = vec2(0.5, 0.0);
        outTexCoord[1] = vec2(0.0, 1.0);
        outTexCoord[2] = vec2(1.0, 1.0);
        outObjectID[0] = outObjectID[1] = outObjectID[2] = 0;
    }
}