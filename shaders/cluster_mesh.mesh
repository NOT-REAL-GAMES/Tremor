#version 460
#extension GL_EXT_mesh_shader : require

// Add struct definitions
struct Cluster {
    uint lightOffset;
    uint lightCount;
    uint objectOffset;
    uint objectCount;
};

struct RenderableObject {
    mat4 transform;
    mat4 prevTransform;
    uint meshID;
    uint materialID;
};

struct ClusterLight {
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
    int type;
    float spotAngle;
    float spotSoftness;
    float padding;
};

// Add descriptor bindings
layout(set = 0, binding = 0) uniform ClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;
    vec4 zPlanes;
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint padding;
};

layout(set = 0, binding = 1) buffer ClusterBuffer {
    Cluster clusters[];
};

layout(set = 0, binding = 2) buffer ObjectBuffer {
    RenderableObject objects[];
};

layout(set = 0, binding = 3) buffer LightBuffer {
    ClusterLight lights[];
};

layout(set = 0, binding = 4) buffer IndexBuffer {
    uint indices[];
};

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 3, max_primitives = 1) out;

// Keep minimal required outputs matching fragment shader inputs
layout(location = 0) out vec3 outPosition[];
layout(location = 1) out vec3 outNormal[];
layout(location = 2) out vec2 outTexCoord[];
layout(location = 3) out vec4 outColor[];
layout(location = 4) out flat uint outObjectID[];

void main() {

    uint clusterIndex = gl_WorkGroupID.x * 32 + gl_LocalInvocationIndex; 
    if (clusterIndex >= numClusters) return; // Skip if beyond cluster count

    // Draw debugging triangle regardless of cluster/workgroup
    if (gl_LocalInvocationIndex == 0) {
        // Force draw a single red triangle
        SetMeshOutputsEXT(3, 1);
        
        gl_MeshVerticesEXT[0].gl_Position = vec4(0.0, 0.9, 0.1, 1.0);  // Near top
        gl_MeshVerticesEXT[1].gl_Position = vec4(-0.1, 0.7, 0.1, 1.0); // Left
        gl_MeshVerticesEXT[2].gl_Position = vec4(0.1, 0.7, 0.1, 1.0);  // Right
        
        gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
        
        // Bright red debug triangle
        outColor[0] = vec4(1.0, 0.0, 0.0, 1.0);
        outColor[1] = vec4(1.0, 0.0, 0.0, 1.0);
        outColor[2] = vec4(1.0, 0.0, 0.0, 1.0);
        
        // Set other attributes
        outPosition[0] = vec3(0.0, 0.9, 0.0);
        outPosition[1] = vec3(-0.1, 0.7, 0.0);
        outPosition[2] = vec3(0.1, 0.7, 0.0);
        
        outNormal[0] = outNormal[1] = outNormal[2] = vec3(0.0, 0.0, 1.0);
        outTexCoord[0] = vec2(0.5, 0.0);
        outTexCoord[1] = vec2(0.0, 1.0);
        outTexCoord[2] = vec2(1.0, 1.0);
        outObjectID[0] = outObjectID[1] = outObjectID[2] = 0;
    }
    
    // Original cluster rendering code...
}