#version 460
#extension GL_EXT_mesh_shader : require  // Add this line

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Enhanced structures
struct Cluster {
    uint lightOffset;
    uint lightCount;
    uint objectOffset;
    uint objectCount;
};

struct EnhancedRenderableObject {
    mat4 transform;
    mat4 prevTransform;
    uint meshID;
    uint materialID;
    uint instanceID;
    uint flags;
};

struct ClusterLight {
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
    int type;
    float spotAngle;
    float spotSoftness;
    float padding;
};

struct MeshInfo {
    uint vertexOffset;
    uint vertexCount;
    uint indexOffset;
    uint indexCount;
    vec3 boundsMin;
    float padding1;
    vec3 boundsMax;
    float padding2;
};

// Enhanced UBO
layout(set = 0, binding = 0) uniform EnhancedClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 invViewMatrix;
    mat4 invProjMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;
    vec4 zPlanes;
    vec4 screenSize;
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint frameNumber;
    float time;
    float deltaTime;
    uint flags;
} ubo;

layout(set = 0, binding = 1) readonly buffer ClusterBuffer {
    Cluster clusters[];
};

layout(set = 0, binding = 2) readonly buffer ObjectBuffer {
    EnhancedRenderableObject objects[];
};

layout(set = 0, binding = 3) readonly buffer LightBuffer {
    ClusterLight lights[];
};

layout(set = 0, binding = 4) readonly buffer IndexBuffer {
    uint indices[];
};

layout(set = 0, binding = 5) readonly buffer MeshInfoBuffer {
    MeshInfo meshInfos[];
};

// Task payload
struct TaskPayload {
    uint clusterIndex;
    uint objectCount;
    uint objectIndices[32];
    uint lightCount;
    uint lightIndices[16];
};

taskPayloadSharedEXT TaskPayload payload;

// Frustum culling
bool isAABBInFrustum(vec3 minBounds, vec3 maxBounds, mat4 mvp) {
    vec3 corners[8] = {
        vec3(minBounds.x, minBounds.y, minBounds.z),
        vec3(maxBounds.x, minBounds.y, minBounds.z),
        vec3(minBounds.x, maxBounds.y, minBounds.z),
        vec3(maxBounds.x, maxBounds.y, minBounds.z),
        vec3(minBounds.x, minBounds.y, maxBounds.z),
        vec3(maxBounds.x, minBounds.y, maxBounds.z),
        vec3(minBounds.x, maxBounds.y, maxBounds.z),
        vec3(maxBounds.x, maxBounds.y, maxBounds.z)
    };
    
    bool anyVisible = false;
    for (int i = 0; i < 8; i++) {
        vec4 clipPos = mvp * vec4(corners[i], 1.0);
        if (clipPos.w > 0.0) {
            vec3 ndc = clipPos.xyz / clipPos.w;
            if (all(greaterThanEqual(ndc, vec3(-1.1))) && all(lessThanEqual(ndc, vec3(1.1)))) {
                anyVisible = true;
                break;
            }
        }
    }
    return anyVisible;
}

void schmain() {
    uint clusterIndex = gl_WorkGroupID.x;
    
    if (gl_LocalInvocationIndex == 0) {
        payload.clusterIndex = clusterIndex;
        payload.objectCount = 0;
        payload.lightCount = 0;
        
        // Debug: Always emit at least one mesh task for testing
        if (clusterIndex == 0) {
            payload.objectCount = 1;
            payload.objectIndices[0] = 0; // Use first object
        }
        
        if (clusterIndex < ubo.numClusters) {
            Cluster cluster = clusters[clusterIndex];
            mat4 mvp = ubo.projMatrix * ubo.viewMatrix;
            
            // Collect visible objects
            uint visibleObjects = 0;
            for (uint i = 0; i < cluster.objectCount && visibleObjects < 32; i++) {
                uint objectIndex = indices[cluster.objectOffset + i];
                if (objectIndex >= ubo.numObjects) continue;
                
                EnhancedRenderableObject obj = objects[objectIndex];
                if ((obj.flags & 1) == 0) continue; // Check visibility flag
                
                if (obj.meshID >= meshInfos.length()) continue;
                MeshInfo meshInfo = meshInfos[obj.meshID];
                
                // Transform bounds to world space
                vec4 minWorld = obj.transform * vec4(meshInfo.boundsMin, 1.0);
                vec4 maxWorld = obj.transform * vec4(meshInfo.boundsMax, 1.0);
                
                if (isAABBInFrustum(minWorld.xyz, maxWorld.xyz, mvp)) {
                    payload.objectIndices[visibleObjects] = objectIndex;
                    visibleObjects++;
                }
            }
            
            // If we found visible objects, use them; otherwise keep debug object for first cluster
            if (visibleObjects > 0 || clusterIndex == 0) {
                if (visibleObjects > 0) {
                    payload.objectCount = visibleObjects;
                }
                
                // Collect cluster lights
                uint visibleLights = 0;
                for (uint i = 0; i < cluster.lightCount && visibleLights < 16; i++) {
                    uint lightIndex = indices[cluster.lightOffset + i];
                    if (lightIndex < ubo.numLights) {
                        payload.lightIndices[visibleLights] = lightIndex;
                        visibleLights++;
                    }
                }
                payload.lightCount = visibleLights;
            }
        }
    }
    
    // Emit mesh workgroups for visible objects
    EmitMeshTasksEXT(payload.objectCount, 0, 0);
}

void main() {
    EmitMeshTasksEXT(1, 0, 0);  // Just emit 1 mesh workgroup
}