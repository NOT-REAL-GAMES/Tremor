#version 460
#extension GL_EXT_mesh_shader : require

// Keep the same descriptor bindings
layout(set = 0, binding = 0) uniform ClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;
    vec4 zPlanes;
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint padding;
};

layout(set = 0, binding = 1) readonly buffer ClusterBuffer {
    uint clusterData[];  // Simplified for testing
};

layout(set = 0, binding = 2) readonly buffer ObjectBuffer {
    uint objectData[];  // Simplified for testing
};

layout(set = 0, binding = 3) readonly buffer LightBuffer {
    uint lightData[];  // Simplified for testing
};

layout(set = 0, binding = 4) readonly buffer IndexBuffer {
    uint indices[];
};

// Simple mesh shader that outputs a single triangle
layout(local_size_x = 1) in;
layout(triangles, max_vertices = 3, max_primitives = 1) out;

// Output vertex attributes
layout(location = 0) out vec3 outPosition[];
layout(location = 1) out vec3 outNormal[];
layout(location = 2) out vec4 outColor[];  // Add a color output

// Buffer validity flags
shared bool clusterBufferValid;
shared bool objectBufferValid; 
shared bool lightBufferValid;
shared bool indexBufferValid;
shared bool uboValid;

void main() {
    // We'll only use one thread for simplicity
    if (gl_LocalInvocationIndex == 0) {
        // Test UBO access - try to read values
        uboValid = true;
        if (projMatrix[0][0] == 0.0 && projMatrix[1][1] == 0.0) {
            // Unlikely that both are zero in a valid projection matrix
            uboValid = false;
        }
        
        // Test each buffer by trying to read from index 0
        // These checks aren't perfect but should catch unbound buffers
        
        // Test cluster buffer
        clusterBufferValid = true;
        if (numClusters > 0) {
            // Safe read - no exception handling needed
            uint clusterTest = clusterData[0]; 
        } else {
            clusterBufferValid = false;
        }
        
        // Test object buffer
        objectBufferValid = true;
        if (numObjects > 0) {
            uint objectTest = objectData[0]; 
        } else {
            objectBufferValid = false;
        }
        
        // Test light buffer
        lightBufferValid = true;
        if (numLights > 0) {
            uint lightTest = lightData[0]; 
        } else {
            lightBufferValid = false;
        }
        
        // Test index buffer - this one might be empty
        indexBufferValid = true;
        uint indexTest = 0;
        // FIXED: No try-catch, just use a conditional
        if (numClusters > 0 && numObjects > 0) {
            indexTest = indices[0]; 
        } else {
            indexBufferValid = false;
        }
        
        // Output triangle vertices
        SetMeshOutputsEXT(3, 1);
        
        // Create a simple triangle in NDC space
        // Vertex 0 (bottom-left)
        gl_MeshVerticesEXT[0].gl_Position = vec4(-0.5, -0.5, 0.0, 1.0);
        outPosition[0] = vec3(-0.5, -0.5, 0.0);
        outNormal[0] = vec3(0.0, 0.0, 1.0);
        
        // Vertex 1 (bottom-right)
        gl_MeshVerticesEXT[1].gl_Position = vec4(0.5, -0.5, 0.0, 1.0);
        outPosition[1] = vec3(0.5, -0.5, 0.0);
        outNormal[1] = vec3(0.0, 0.0, 1.0);
        
        // Vertex 2 (top)
        gl_MeshVerticesEXT[2].gl_Position = vec4(0.0, 0.5, 0.0, 1.0);
        outPosition[2] = vec3(0.0, 0.5, 0.0);
        outNormal[2] = vec3(0.0, 0.0, 1.0);
        
        // Determine color based on buffer validity
        vec4 vertexColor;
        if (uboValid && clusterBufferValid && objectBufferValid && lightBufferValid && indexBufferValid) {
            // All buffers are valid - GREEN
            vertexColor = vec4(0.0, 1.0, 0.0, 1.0);
        } else {
            // Some buffers are invalid - RED with indicators in other channels
            float blue = 0.0;
            // Encode which buffers are invalid in the blue channel
            if (!uboValid) blue += 0.2;
            if (!clusterBufferValid) blue += 0.4;
            if (!objectBufferValid) blue += 0.1;
            if (!lightBufferValid) blue += 0.05;
            if (!indexBufferValid) blue += 0.025;
            
            vertexColor = vec4(1.0, 0.0, blue, 1.0);
        }
        
        // Set same color for all vertices
        outColor[0] = vertexColor;
        outColor[1] = vertexColor;
        outColor[2] = vertexColor;
        
        // Set single triangle
        gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    }
}