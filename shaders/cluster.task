// cluster.task - Fixed clustered rendering task shader
#version 460
#extension GL_EXT_mesh_shader : require

// Enhanced UBO matching your ClusterUBO structure
layout(set = 0, binding = 0) uniform ClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 invViewMatrix;
    mat4 invProjMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;  // x, y, z slices + padding
    vec4 zPlanes;             // near, far, clustersPerZ, padding
    vec4 screenSize;          // width, height, 1/width, 1/height
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint frameNumber;
    float time;
    float deltaTime;
    uint flags;
} ubo;

// Cluster data structure (must match C++ exactly)
struct Cluster {
    uint lightOffset;
    uint lightCount;
    uint objectOffset;
    uint objectCount;
};

layout(set = 0, binding = 1) readonly buffer ClusterBuffer {
    Cluster clusters[];
};

// Task shader workgroup size - process clusters efficiently
layout(local_size_x = 32) in;

// Shared memory for efficient cluster processing
shared uint s_visibleClusters[32];
shared uint s_clusterCount;

void main() {
    uint threadID = gl_LocalInvocationID.x;
    uint groupID = gl_WorkGroupID.x;
    uint globalClusterID = groupID * 32 + threadID;
    
    // Initialize shared memory on first thread
    if (threadID == 0) {
        s_clusterCount = 0;
    }
    
    barrier();
    
    // Check if this thread represents a valid cluster
    bool isValidCluster = (globalClusterID < ubo.numClusters);
    bool hasObjects = false;
    
    if (isValidCluster && globalClusterID < clusters.length()) {
        Cluster cluster = clusters[globalClusterID];
        hasObjects = (cluster.objectCount > 0);
        
        // Simple frustum culling could be added here
        // For now, just check if cluster has objects
    }
    
    // Atomically add visible clusters to shared list
    if (hasObjects) {
        uint clusterIndex = atomicAdd(s_clusterCount, 1);
        if (clusterIndex < 32) {
            s_visibleClusters[clusterIndex] = globalClusterID;
        }
    }
    
    barrier();
    
    // Emit mesh tasks for all visible clusters in this workgroup
    if (threadID == 0) {
        uint clustersToEmit = min(s_clusterCount, 32u);
        if (clustersToEmit > 0) {
            // Each mesh workgroup will process one cluster
            EmitMeshTasksEXT(clustersToEmit, 0, 0);
        }
    }
}