// cluster_mesh.mesh - FIXED VERSION  
#version 460
#extension GL_EXT_mesh_shader : require

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 42) out;

// Enhanced UBO
layout(set = 0, binding = 0) uniform EnhancedClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 invViewMatrix;
    mat4 invProjMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;
    vec4 zPlanes;
    vec4 screenSize;
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint frameNumber;
    float time;
    float deltaTime;
    uint flags;
} ubo;

// Task payload
struct TaskPayload {
    uint clusterIndex;
    uint objectCount;
    uint objectIndices[32];
    uint lightCount;
    uint lightIndices[16];
};

taskPayloadSharedEXT TaskPayload payload;

// Output attributes
layout(location = 0) out vec3 outWorldPos[];
layout(location = 1) out vec3 outNormal[];
layout(location = 2) out vec3 outTangent[];
layout(location = 3) out vec3 outBitangent[];
layout(location = 4) out vec2 outTexCoord[];
layout(location = 5) out vec3 outViewPos[];
layout(location = 6) out vec4 outPrevClipPos[];
layout(location = 7) out flat uint outMaterialID[];
layout(location = 8) out flat uint outClusterIndex[];
layout(location = 9) out flat uint outInstanceID[];

void main() {
    // For testing: just render a simple triangle
    if (gl_LocalInvocationIndex == 0) {
        SetMeshOutputsEXT(3, 1);
        
        // Animated triangle based on time
        float time = ubo.time;
        float s = sin(time) * 0.3;
        float c = cos(time) * 0.3;
        
        gl_MeshVerticesEXT[0].gl_Position = vec4(-0.5 + s, -0.5 + c, 0.0, 1.0);
        gl_MeshVerticesEXT[1].gl_Position = vec4( 0.5 + s, -0.5 + c, 0.0, 1.0);
        gl_MeshVerticesEXT[2].gl_Position = vec4( 0.0 + s,  0.5 + c, 0.0, 1.0);
        
        gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
        
        // Set output attributes
        for (int i = 0; i < 3; i++) {
            outWorldPos[i] = vec3(0.0);
            outNormal[i] = vec3(0.0, 0.0, 1.0);
            outTangent[i] = vec3(1.0, 0.0, 0.0);
            outBitangent[i] = vec3(0.0, 1.0, 0.0);
            outTexCoord[i] = vec2(0.5);
            outViewPos[i] = vec3(0.0);
            outPrevClipPos[i] = vec4(0.0, 0.0, 0.0, 1.0);
            outMaterialID[i] = 0;
            outClusterIndex[i] = payload.clusterIndex;
            outInstanceID[i] = 0;
        }
    }
}