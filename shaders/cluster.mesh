// debug_mesh_only.mesh - Simplified mesh shader for debugging (no task shader)
#version 460
#extension GL_EXT_mesh_shader : require

// Simplified UBO for debugging
layout(set = 0, binding = 0) uniform ClusterUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 invViewMatrix;
    mat4 invProjMatrix;
    vec4 cameraPos;
    uvec4 clusterDimensions;
    vec4 zPlanes;
    vec4 screenSize;
    uint numLights;
    uint numObjects;
    uint numClusters;
    uint frameNumber;
    float time;
    float deltaTime;
    uint flags;
} ubo;

struct Cluster {
    uint lightOffset;
    uint lightCount;
    uint objectOffset;
    uint objectCount;
};

struct RenderableObject {
    mat4 transform;
    mat4 prevTransform;
    uint meshID;
    uint materialID;
    uint instanceID;
    uint flags;
};

struct MeshInfo {
    uint vertexOffset;
    uint vertexCount;
    uint indexOffset;
    uint indexCount;
    vec3 boundsMin;
    float padding1;
    vec3 boundsMax;
    float padding2;
};

struct Vertex {
    vec3 position;
    vec3 normal;
    vec2 texCoord;
    vec4 tangent;
};

layout(set = 0, binding = 1) readonly buffer ClusterBuffer {
    Cluster clusters[];
};

layout(set = 0, binding = 2) readonly buffer ObjectBuffer {
    RenderableObject objects[];
};

layout(set = 0, binding = 4) readonly buffer IndexBuffer {
    uint clusterObjectIndices[];
};

layout(set = 0, binding = 5) readonly buffer MeshInfoBuffer {
    MeshInfo meshInfos[];
};

layout(set = 0, binding = 6) readonly buffer VertexBuffer {
    Vertex vertices[];
};

layout(set = 0, binding = 7) readonly buffer MeshIndexBuffer {
    uint meshIndices[];
};

layout(local_size_x = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 32) out;

layout(location = 0) out vec3 fragWorldPos[];
layout(location = 1) out vec3 fragNormal[];
layout(location = 2) out vec2 fragTexCoord[];
layout(location = 3) out vec3 fragTangent[];
layout(location = 4) out vec3 fragBitangent[];
layout(location = 5) flat out uint fragMaterialID[];

void main() {
    // For debugging: just render cluster 0 which should have all objects
    uint clusterIndex = 0;
    
    Cluster cluster = clusters[clusterIndex];
    
    // Process first object in cluster 0    
    uint objectIndex = clusterObjectIndices[cluster.objectOffset];
        
    RenderableObject obj = objects[objectIndex];
    
    MeshInfo meshInfo = meshInfos[obj.meshID];
    
    // For debugging: render a simple triangle if we have at least 3 vertices
    uint numVertices = min(meshInfo.vertexCount, 3u);

    
    SetMeshOutputsEXT(3, 1);
    
    // Transform matrix
    mat4 mvpMatrix = ubo.projMatrix * ubo.viewMatrix * obj.transform;
    
    // Render first triangle only
    for (uint i = 0; i < 3; ++i) {
        uint vertexIndex = meshInfo.vertexOffset + i;
        
        if (true) {
            // Fallback positions for a simple triangle
            vec3 positions[3] = vec3[](
                vec3(-0.5, -0.5, 0.0),
                vec3( 0.5, -0.5, 0.0),
                vec3( 0.0,  0.5, 0.0)
            );
            
            gl_MeshVerticesEXT[i].gl_Position = vec4(positions[i], 1.0) + vec4(sin(ubo.frameNumber),0.0,0.0,0.0);
            fragWorldPos[i] = (obj.transform * vec4(positions[i], 1.0)).xyz;
            fragNormal[i] = vec3(0.0, 0.0, 1.0);
            fragTexCoord[i] = vec2(0.0);
            fragTangent[i] = vec3(1.0, 0.0, 0.0);
            fragBitangent[i] = vec3(0.0, 1.0, 0.0);
            fragMaterialID[i] = obj.materialID;
        } else {
            
        }
    }
    
    // Single triangle
    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
}